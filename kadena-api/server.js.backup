const express = require("express");
const cors = require("cors");
const { Pact, createClient } = require("@kadena/client");
const BigNumber = require("bignumber.js"); // Import BigNumber
const fs = require("fs");
const yaml = require("js-yaml");
const path = require("path");

let rateLimit, helmet, morgan, dotenv;
try {
  rateLimit = require("express-rate-limit");
  helmet = require("helmet");
  morgan = require("morgan");
  dotenv = require("dotenv");
  dotenv?.config();
} catch (err) {
  console.warn("Optional dependencies not available");
}

// --- Configuration ---
// Read from environment variables with fallbacks
const KADENA_NETWORK_ID = process.env.KADENA_NETWORK_ID || "mainnet01";
const KADENA_API_HOST =
  process.env.KADENA_API_HOST || `https://api.chainweb.com`;
const KADDEX_NAMESPACE = process.env.KADDEX_NAMESPACE || "kaddex";
const NETWORK_VERSION = process.env.NETWORK_VERSION || "0.0";
const PORT = process.env.PORT || 3000;
const NODE_ENV = process.env.NODE_ENV || "development";
const VERSION = process.env.npm_package_version || "1.0.0";

// Load token data from tokens.yml
let tokenData = {};
try {
  const tokensFilePath = path.join(__dirname, "tokens.yml");
  if (fs.existsSync(tokensFilePath)) {
    const tokensFile = fs.readFileSync(tokensFilePath, "utf8");
    const parsedTokens = yaml.load(tokensFile);

    // Use the network ID to get the right tokens for the current network
    if (parsedTokens && parsedTokens[KADENA_NETWORK_ID.toLowerCase()]) {
      tokenData = parsedTokens[KADENA_NETWORK_ID.toLowerCase()];
      console.log(
        `Loaded ${
          Object.keys(tokenData).length
        } tokens for ${KADENA_NETWORK_ID}`
      );
    } else if (parsedTokens && parsedTokens.mainnet) {
      // Default to mainnet tokens if current network tokens not found
      tokenData = parsedTokens.mainnet;
      console.log(
        `Using mainnet tokens as fallback (${
          Object.keys(tokenData).length
        } tokens)`
      );
    }
  } else {
    console.warn("tokens.yml not found, token precision will use defaults");
  }
} catch (err) {
  console.error("Error loading tokens.yml:", err);
}

// Helper function to get token precision from tokenData
const getTokenPrecision = (tokenCode) => {
  // Default precision for most tokens
  const DEFAULT_PRECISION = 12;

  if (!tokenCode) return DEFAULT_PRECISION;

  // Handle special case for coin/KDA
  if (tokenCode === "coin")
    return tokenData.coin?.precision || DEFAULT_PRECISION;

  // Look for token in our token data
  if (tokenData[tokenCode]?.precision !== undefined) {
    return tokenData[tokenCode].precision;
  }

  // If we can't find it, return the default
  return DEFAULT_PRECISION;
};

// Ensure Pact.lang is accessible for mkCap
const pactLang = Pact.lang;
if (!pactLang || !pactLang.mkCap) {
  console.error(
    "Warning: Pact.lang.mkCap not found, creating a fallback implementation"
  );
  // Create a fallback mkCap function if not available
  Pact.lang = Pact.lang || {};
  Pact.lang.mkCap =
    Pact.lang.mkCap ||
    function (name, description, module, args) {
      return {
        name: name,
        description: description,
        module: module,
        args: Array.isArray(args) ? args : [args],
      };
    };
}

const app = express();

// --- Middleware ---
// Only use production middleware if packages are available
if (rateLimit) {
  // --- Rate Limiting ---
  const apiLimiter = rateLimit({
    windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes
    max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100, // Limit each IP to 100 requests per windowMs
    standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
    legacyHeaders: false, // Disable the `X-RateLimit-*` headers
    message: {
      error: "Too many requests",
      details: "Rate limit exceeded",
    },
  });

  // Apply rate limiting to all requests
  app.use(apiLimiter);
}

// Security headers
if (helmet) {
  app.use(helmet());
}

// Request logging
if (morgan) {
  app.use(morgan(NODE_ENV === "production" ? "combined" : "dev"));
}

app.use(cors()); // Allow requests from frontend origins
app.use(express.json()); // Parse JSON request bodies

// Global error handler
app.use((err, req, res, next) => {
  console.error("Unhandled error:", err);
  res.status(500).json({
    error: "Internal server error",
    details: NODE_ENV === "production" ? undefined : err.message,
  });
});

// --- Helper Functions ---

// Helper function to ensure chainId is a string
const ensureChainIdString = (chainId) => {
  return chainId !== undefined && chainId !== null ? String(chainId) : "2"; // Default to chain 2 if undefined
};

const getClient = (chainId) =>
  createClient(
    `${KADENA_API_HOST}/chainweb/${NETWORK_VERSION}/${KADENA_NETWORK_ID}/chain/${ensureChainIdString(
      chainId
    )}/pact`
  );

const reduceBalance = (value, precision = 12) => {
  if (value === undefined || value === null) return "0.0";
  try {
    // Handle values that might come as objects with decimal or int properties
    if (value.decimal) value = value.decimal;
    if (value.int) value = value.int;

    // Configure BigNumber for decimal truncation
    BigNumber.config({
      DECIMAL_PLACES: precision,
      ROUNDING_MODE: BigNumber.ROUND_DOWN,
    });

    // Parse as BigNumber and fix decimal places
    const bn = new BigNumber(value);
    if (bn.isNaN()) return "0.0";

    // Return formatted value with exact precision
    return bn.toFixed(precision);
  } catch (error) {
    console.error(`Error reducing balance: ${value}`, error);
    return "0.0";
  }
};

const creationTime = () => Math.round(new Date().getTime() / 1000) - 10;

const createTokenId = async (chainId, precision, guard, policy, uri) => {
  const pactClient = getClient(chainId);
  let policyName =
    policy === "DEFAULT_COLLECTION_NON_UPDATABLE"
      ? "marmalade-v2.non-fungible-policy-v1"
      : policy === "DEFAULT_COLLECTION_ROYALTY_NON_UPDATABLE"
      ? "marmalade-v2.royalty-policy-v1"
      : policy;

  const code = `(use marmalade-v2.ledger)(use marmalade-v2.util-v1)(create-token-id { 'precision: ${precision}, 'policies: [${policyName}], 'uri: "${uri}"} (read-keyset 'ks))`;
  const tx = Pact.builder
    .execution(code)
    .setMeta({ chainId: String(chainId), gasLimit: 80000, gasPrice: 0.0000001 })
    .addData("ks", guard)
    .setNetworkId(KADENA_NETWORK_ID)
    .createTransaction();

  try {
    const response = await pactClient.dirtyRead(tx);
    return response?.result?.status === "success" ? response.result.data : null;
  } catch (error) {
    console.error("Error generating token ID:", error);
    throw error;
  }
};

// --- API Endpoints ---

/**
 * GET /health
 * Health check endpoint
 */
app.get("/health", (req, res) => {
  res.json({
    status: "healthy",
    timestamp: new Date().toISOString(),
    version: VERSION,
    environment: NODE_ENV,
    network: {
      networkId: KADENA_NETWORK_ID,
      apiHost: KADENA_API_HOST,
    },
  });
});

/**
 * POST /quote
 * Calculates swap estimates based on reserve data.
 */
app.post("/quote", async (req, res) => {
  try {
    const {
      tokenInAddress,
      tokenOutAddress,
      amountIn,
      amountOut,
      chainId = "2",
    } = req.body;

    // Validate required parameters
    if (ensureChainIdString(chainId) !== "2") {
      return res
        .status(400)
        .json({ error: "Currently only chainId 2 is supported" });
    }

    if (!tokenInAddress || !tokenOutAddress) {
      return res.status(400).json({
        error: "Missing required parameters",
        details: "tokenInAddress and tokenOutAddress are required",
      });
    }

    if ((!amountIn && !amountOut) || (amountIn && amountOut)) {
      return res.status(400).json({
        error: "Invalid amount parameters",
        details: "Provide either amountIn or amountOut, not both",
      });
    }

    // Parse amount
    const isExactIn = !!amountIn;
    let amount;
    try {
      amount = new BigNumber(amountIn || amountOut);
      if (amount.isNaN() || amount.isLessThanOrEqualTo(0)) {
        return res.status(400).json({
          error: "Invalid amount",
          details: "Amount must be greater than 0",
        });
      }
    } catch (error) {
      return res.status(400).json({
        error: "Invalid amount format",
        details: error.message,
      });
    }

    // Get token precision from tokens.yml
    const tokenInPrecision = getTokenPrecision(tokenInAddress);
    const tokenOutPrecision = getTokenPrecision(tokenOutAddress);

    console.log(
      `Using precision for ${tokenInAddress}: ${tokenInPrecision}, ${tokenOutAddress}: ${tokenOutPrecision}`
    );

    // Constants
    const ONE = new BigNumber(1);
    const FEE = new BigNumber("0.003"); // 0.3% fee
    const pactClient = getClient(chainId);

    // 1. Fetch reserves
    const reservesCmd = Pact.builder
      .execution(
        `(use ${KADDEX_NAMESPACE}.exchange) 
         (let* ((p (get-pair ${tokenInAddress} ${tokenOutAddress})) 
                (reserveA (reserve-for p ${tokenInAddress})) 
                (reserveB (reserve-for p ${tokenOutAddress}))) 
          [reserveA reserveB])`
      )
      .setMeta({ chainId: ensureChainIdString(chainId) })
      .setNetworkId(KADENA_NETWORK_ID)
      .createTransaction();

    console.log(
      "Fetching reserves for quote with command:",
      JSON.stringify(reservesCmd, null, 2)
    );

    const reservesData = await pactClient.local(reservesCmd, {
      preflight: false,
      signatureVerification: false,
    });

    // Validate reserve data
    if (
      reservesData?.result?.status !== "success" ||
      !Array.isArray(reservesData.result.data) ||
      reservesData.result.data.length < 2
    ) {
      console.error(
        "Failed to get valid reserves:",
        reservesData?.result?.error || "Unknown error"
      );
      return res.status(404).json({
        error: "Liquidity pool not found",
        details: "Could not find a valid trading pair for the provided tokens",
      });
    }

    // Parse reserve values with careful error handling
    let reserveIn, reserveOut;
    try {
      const reserve0 = reservesData.result.data[0];
      const reserve1 = reservesData.result.data[1];

      reserveIn = new BigNumber(
        typeof reserve0 === "object" ? reserve0.decimal || 0 : reserve0 || 0
      );
      reserveOut = new BigNumber(
        typeof reserve1 === "object" ? reserve1.decimal || 0 : reserve1 || 0
      );
    } catch (error) {
      console.error("Error parsing reserves:", error);
      return res.status(500).json({
        error: "Failed to parse reserves",
        details: error.message,
      });
    }

    // Verify reserves are valid
    if (reserveIn.isLessThanOrEqualTo(0) || reserveOut.isLessThanOrEqualTo(0)) {
      return res.status(404).json({
        error: "Insufficient liquidity",
        details: "Liquidity pool has no liquidity",
      });
    }

    // Calculate quote
    let calculatedAmountBn;
    let priceImpact = "0.00";

    try {
      if (isExactIn) {
        // Calculate amountOut based on input amount
        const amountInWithFee = amount.times(ONE.minus(FEE));
        const numerator = amountInWithFee.times(reserveOut);
        const denominator = reserveIn.plus(amountInWithFee);

        if (denominator.isLessThanOrEqualTo(0)) {
          return res.status(400).json({
            error: "Invalid calculation",
            details: "Calculation resulted in invalid denominator",
          });
        }

        calculatedAmountBn = numerator.dividedBy(denominator);

        // Calculate price impact
        const midPrice = reserveOut.dividedBy(reserveIn);
        const exactQuote = amount.times(midPrice);
        if (exactQuote.isGreaterThan(0)) {
          const slippage = ONE.minus(calculatedAmountBn.dividedBy(exactQuote));
          priceImpact = slippage.times(100).toFixed(2);
        }

        return res.json({
          amountOut: reduceBalance(calculatedAmountBn, tokenOutPrecision),
          priceImpact: priceImpact,
        });
      } else {
        // Calculate amountIn based on exact output
        const numerator = reserveIn.times(amount);
        const denominator = reserveOut.minus(amount).times(ONE.minus(FEE));

        if (denominator.isLessThanOrEqualTo(0)) {
          return res.status(400).json({
            error: "Insufficient liquidity",
            details: "Output amount too large for this pool",
          });
        }

        calculatedAmountBn = numerator.dividedBy(denominator);

        // Calculate price impact
        const midPrice = reserveIn.dividedBy(reserveOut);
        const exactQuote = amount.times(midPrice);
        if (exactQuote.isGreaterThan(0)) {
          const slippage = calculatedAmountBn.dividedBy(exactQuote).minus(ONE);
          priceImpact = slippage.times(100).toFixed(2);
        }

        return res.json({
          amountIn: reduceBalance(calculatedAmountBn, tokenInPrecision),
          priceImpact: priceImpact,
        });
      }
    } catch (error) {
      console.error("Error calculating quote:", error);
      return res.status(500).json({
        error: "Quote calculation failed",
        details: error.message,
      });
    }
  } catch (error) {
    console.error("Unhandled error in /quote endpoint:", error);
    return res.status(500).json({
      error: "Internal server error",
      details: NODE_ENV === "production" ? undefined : error.message,
    });
  }
});

/**
 * POST /swap
 * Generates an unsigned swap transaction.
 */
app.post("/swap", async (req, res) => {
  try {
    const {
      tokenInAddress,
      tokenOutAddress,
      amountIn,
      amountOut,
      account,
      slippage = "0.005", // Default 0.5%
      chainId = "2",
    } = req.body;

    // Validate required fields
    if (
      !account ||
      !tokenInAddress ||
      !tokenOutAddress ||
      !slippage ||
      !(amountIn || amountOut)
    ) {
      return res.status(400).json({
        error: "Missing required fields",
        details:
          "Account, tokenInAddress, tokenOutAddress, slippage, and (amountIn or amountOut) are required",
      });
    }

    // Validate account format
    if (!account.startsWith("k:")) {
      return res.status(400).json({
        error: "Invalid account format",
        details: "Account must start with 'k:'",
      });
    }

    // Parse amount and validate
    const isExactIn = !!amountIn;
    let amount;
    try {
      amount = new BigNumber(amountIn || amountOut);
      if (amount.isNaN() || amount.isLessThanOrEqualTo(0)) {
        return res.status(400).json({
          error: "Invalid amount",
          details: "Amount must be greater than 0",
        });
      }
    } catch (error) {
      return res.status(400).json({
        error: "Invalid amount format",
        details: error.message,
      });
    }

    // Get token precision from tokens.yml
    const tokenInPrecision = getTokenPrecision(tokenInAddress);
    const tokenOutPrecision = getTokenPrecision(tokenOutAddress);

    console.log(
      `Using precision for ${tokenInAddress}: ${tokenInPrecision}, ${tokenOutAddress}: ${tokenOutPrecision}`
    );

    // Parse slippage tolerance
    let slippageTolerance;
    try {
      slippageTolerance = new BigNumber(slippage);
      if (
        slippageTolerance.isNaN() ||
        slippageTolerance.isLessThan(0) ||
        slippageTolerance.isGreaterThan(0.5)
      ) {
        return res.status(400).json({
          error: "Invalid slippage value",
          details: "Must be between 0 and 0.5 (50%)",
        });
      }
    } catch (error) {
      return res.status(400).json({
        error: "Invalid slippage format",
        details: error.message,
      });
    }

    // Constants
    const ONE = new BigNumber(1);
    const FEE = new BigNumber("0.003"); // 0.3% fee
    const pactClient = getClient(chainId);

    // 1. Fetch account guard to include in the transaction
    console.log(`Fetching account details for ${account}`);
    const accountDetailsCmd = Pact.builder
      .execution(`(coin.details "${account}")`)
      .setMeta({ chainId: ensureChainIdString(chainId), sender: account })
      .setNetworkId(KADENA_NETWORK_ID)
      .createTransaction();

    const accountDetailsData = await pactClient.local(accountDetailsCmd, {
      preflight: false,
      signatureVerification: false,
    });

    // Log the account details response for debugging
    console.log(
      "Account details response:",
      JSON.stringify(accountDetailsData, null, 2)
    );

    if (
      accountDetailsData?.result?.status !== "success" ||
      !accountDetailsData.result.data?.guard
    ) {
      console.error(
        "Failed to get account details:",
        accountDetailsData?.result?.error || "Unknown error"
      );
      return res.status(404).json({
        error: "Account not found",
        details: "Could not retrieve account details from blockchain",
      });
    }

    const userGuard = accountDetailsData.result.data.guard;

    // 2. Fetch reserves
    const reservesCmd = Pact.builder
      .execution(
        `(use ${KADDEX_NAMESPACE}.exchange) 
         (let* ((p (get-pair ${tokenInAddress} ${tokenOutAddress})) 
                (reserveA (reserve-for p ${tokenInAddress})) 
                (reserveB (reserve-for p ${tokenOutAddress}))) 
          [reserveA reserveB])`
      )
      .setMeta({ chainId: ensureChainIdString(chainId) })
      .setNetworkId(KADENA_NETWORK_ID)
      .createTransaction();

    console.log(
      "Fetching reserves with command:",
      JSON.stringify(reservesCmd, null, 2)
    );

    const reservesData = await pactClient.local(reservesCmd, {
      preflight: false,
      signatureVerification: false,
    });

    // Validate reserve data
    if (
      reservesData?.result?.status !== "success" ||
      !Array.isArray(reservesData.result.data) ||
      reservesData.result.data.length < 2
    ) {
      console.error(
        "Failed to get valid reserves:",
        reservesData?.result?.error || "Unknown error"
      );
      return res.status(404).json({
        error: "Liquidity pool not found",
        details: "Could not find a valid trading pair for the provided tokens",
      });
    }

    // Parse reserve values with careful error handling
    let reserveIn, reserveOut;
    try {
      const reserve0 = reservesData.result.data[0];
      const reserve1 = reservesData.result.data[1];

      reserveIn = new BigNumber(
        typeof reserve0 === "object" ? reserve0.decimal || 0 : reserve0 || 0
      );
      reserveOut = new BigNumber(
        typeof reserve1 === "object" ? reserve1.decimal || 0 : reserve1 || 0
      );
    } catch (error) {
      console.error("Error parsing reserves:", error);
      return res.status(500).json({
        error: "Failed to parse reserves",
        details: error.message,
      });
    }

    // Verify reserves are valid
    if (reserveIn.isLessThanOrEqualTo(0) || reserveOut.isLessThanOrEqualTo(0)) {
      return res.status(404).json({
        error: "Insufficient liquidity",
        details: "Liquidity pool has no liquidity",
      });
    }

    // 3. Calculate swap amounts with slippage
    let token0AmountBn; // Amount of tokenIn
    let token1AmountBn; // Amount of tokenOut
    let token0AmountWithSlippageBn; // Max IN if swapping OUT
    let token1AmountWithSlippageBn; // Min OUT if swapping IN

    try {
      if (isExactIn) {
        // Swap exact in - calculate expected output based on input amount
        token0AmountBn = amount;
        const amountInWithFee = token0AmountBn.times(ONE.minus(FEE));
        const numerator = amountInWithFee.times(reserveOut);
        const denominator = reserveIn.plus(amountInWithFee);

        if (denominator.isLessThanOrEqualTo(0)) {
          return res.status(400).json({
            error: "Invalid calculation",
            details: "Calculation resulted in invalid denominator",
          });
        }

        token1AmountBn = numerator.dividedBy(denominator);

        // Minimum output acceptable based on slippage
        token1AmountWithSlippageBn = token1AmountBn.times(
          ONE.minus(slippageTolerance)
        );
        token0AmountWithSlippageBn = token0AmountBn; // No slippage for exact input
      } else {
        // Swap exact out - calculate required input based on output amount
        token1AmountBn = amount;

        if (token1AmountBn.isGreaterThanOrEqualTo(reserveOut)) {
          return res.status(400).json({
            error: "Insufficient liquidity",
            details: "Output amount exceeds available reserves",
          });
        }

        const numerator = reserveIn.times(token1AmountBn);
        const denominator = reserveOut
          .minus(token1AmountBn)
          .times(ONE.minus(FEE));

        if (denominator.isLessThanOrEqualTo(0)) {
          return res.status(400).json({
            error: "Invalid calculation",
            details: "Calculation resulted in invalid denominator",
          });
        }

        token0AmountBn = numerator.dividedBy(denominator);

        // Maximum input acceptable based on slippage
        token0AmountWithSlippageBn = token0AmountBn.times(
          ONE.plus(slippageTolerance)
        );
        token1AmountWithSlippageBn = token1AmountBn; // No slippage for exact output
      }
    } catch (error) {
      console.error("Calculation error:", error);
      return res.status(500).json({
        error: "Swap calculation failed",
        details: error.message,
      });
    }

    // Format amounts with proper precision
    const token0AmountStr = reduceBalance(token0AmountBn, tokenInPrecision);
    const token1AmountStr = reduceBalance(token1AmountBn, tokenOutPrecision);
    const token0AmountWithSlippageStr = reduceBalance(
      token0AmountWithSlippageBn,
      tokenInPrecision
    );
    const token1AmountWithSlippageStr = reduceBalance(
      token1AmountWithSlippageBn,
      tokenOutPrecision
    );

    // 4. Get the pair account for TRANSFER capability
    const pairAccountCmd = Pact.builder
      .execution(
        `(use ${KADDEX_NAMESPACE}.exchange) 
         (at 'account (get-pair ${tokenInAddress} ${tokenOutAddress}))`
      )
      .setMeta({ chainId: ensureChainIdString(chainId) })
      .setNetworkId(KADENA_NETWORK_ID)
      .createTransaction();

    let pairAccount;
    try {
      const pairAccountData = await pactClient.local(pairAccountCmd, {
        preflight: false,
        signatureVerification: false,
      });

      if (
        pairAccountData?.result?.status !== "success" ||
        !pairAccountData.result.data
      ) {
        throw new Error("Failed to fetch pair account");
      }

      pairAccount = pairAccountData.result.data;
    } catch (error) {
      console.error("Error fetching pair account:", error);
      // Use a fallback value in case of error
      pairAccount = `${KADDEX_NAMESPACE}.exchange-swap-pair`;
      console.log(`Using fallback pair account: ${pairAccount}`);
    }

    // 5. Construct the transaction code based on swap type
    const pactCode = isExactIn
      ? `(${KADDEX_NAMESPACE}.exchange.swap-exact-in 
          (read-decimal 'token0Amount) 
          (read-decimal 'token1AmountWithSlippage) 
          [${tokenInAddress} ${tokenOutAddress}] 
          (read-string 'sender) 
          (read-string 'receiver) 
          (read-keyset 'user-ks))`
      : `(${KADDEX_NAMESPACE}.exchange.swap-exact-out 
          (read-decimal 'token1Amount) 
          (read-decimal 'token0AmountWithSlippage) 
          [${tokenInAddress} ${tokenOutAddress}] 
          (read-string 'sender) 
          (read-string 'receiver) 
          (read-keyset 'user-ks))`;

    // 6. Prepare transaction data and environment
    const envData = {
      "user-ks": userGuard,
      sender: account,
      receiver: account,
      token0Amount: token0AmountStr,
      token1Amount: token1AmountStr,
      token0AmountWithSlippage: token0AmountWithSlippageStr,
      token1AmountWithSlippage: token1AmountWithSlippageStr,
    };

    // Transaction metadata
    const txMeta = {
      chainId: ensureChainIdString(chainId),
      sender: account,
      gasLimit: 10000,
      gasPrice: 0.000001,
      ttl: 28800,
      creationTime: creationTime(),
    };

    // Amount for TRANSFER capability depends on swap direction
    const transferAmountStr = isExactIn
      ? token0AmountStr
      : token0AmountWithSlippageStr;

    // 7. Create transaction with proper capabilities
    try {
      const pactCommand = {
        networkId: KADENA_NETWORK_ID,
        payload: {
          exec: {
            data: envData,
            code: pactCode,
          },
        },
        signers: [
          {
            pubKey: userGuard.keys[0],
            scheme: "ED25519",
            clist: [
              // Gas capability
              {
                name: "Gas",
                args: [],
                pred: "coin.GAS",
              },
              // Transfer capability
              {
                name: "Transfer",
                pred: `${tokenInAddress}.TRANSFER`,
                args: [account, pairAccount, { decimal: transferAmountStr }],
              },
            ],
          },
        ],
        meta: txMeta,
        nonce: `swap:${Date.now()}:${Math.random()
          .toString(36)
          .substring(2, 15)}`,
      };

      // Final transaction object for client signing
      const preparedTx = {
        cmd: JSON.stringify(pactCommand),
        hash: "hash_placeholder", // Will be recalculated by the client
        sigs: [null], // Will be filled by the client
      };

      // 8. Return the transaction data and relevant metadata
      return res.json({
        transaction: preparedTx,
        quote: {
          expectedIn: token0AmountStr,
          expectedOut: token1AmountStr,
          slippage: slippage,
          priceImpact: calculatePriceImpact(
            reserveIn,
            reserveOut,
            token0AmountBn,
            token1AmountBn
          ),
        },
      });
    } catch (error) {
      console.error("Error building transaction:", error);
      return res.status(500).json({
        error: "Transaction preparation failed",
        details: error.message,
      });
    }
  } catch (error) {
    console.error("Unhandled error in /swap endpoint:", error);
    return res.status(500).json({
      error: "Internal server error",
      details: NODE_ENV === "production" ? undefined : error.message,
    });
  }
});

/**
 * Helper function to calculate price impact of a swap
 * @param {BigNumber} reserveIn - Reserve of input token
 * @param {BigNumber} reserveOut - Reserve of output token
 * @param {BigNumber} amountIn - Amount of input token
 * @param {BigNumber} amountOut - Amount of output token
 * @returns {string} - Price impact as a percentage string
 */
function calculatePriceImpact(reserveIn, reserveOut, amountIn, amountOut) {
  try {
    // Define ONE constant inside this function scope
    const ONE = new BigNumber(1);

    // Calculate mid price before swap
    const midPrice = reserveOut.dividedBy(reserveIn);

    // Calculate expected out without price impact (at mid price)
    const expectedOut = amountIn.times(midPrice);

    // Calculate price impact as percentage
    if (expectedOut.isEqualTo(0)) return "0.00";

    const impact = ONE.minus(amountOut.dividedBy(expectedOut));

    // Format as percentage with 2 decimal places
    return impact.times(100).toFixed(2);
  } catch (error) {
    console.error("Error calculating price impact:", error);
    return "0.00";
  }
}

/**
 * POST /launch-nft
 * Generates an unsigned NFT creation and minting transaction (Marmalade v2).
 */
app.post("/launch-nft", async (req, res) => {
  try {
    const {
      account, // k:account format
      guard, // { keys: [...], pred: '...' }
      mintTo, // k:account format
      uri, // IPFS URI or other metadata link
      precision = 0, // Usually 0 for NFTs
      policy = "DEFAULT_COLLECTION_NON_UPDATABLE", // Or "DEFAULT_COLLECTION_ROYALTY_NON_UPDATABLE"
      collectionId, // Pre-existing collection ID string
      royalties = 0, // Decimal percentage e.g. 2.5
      royaltyRecipient = null, // k:account format, required if royalties > 0
      chainId = "2",
      name, // Optional metadata
      description, // Optional metadata
    } = req.body;

    // 1. Validate required parameters
    if (ensureChainIdString(chainId) !== "2") {
      return res.status(400).json({
        error: "Operation not supported",
        details: "Currently only chainId 2 is supported",
      });
    }

    // Validate all required parameters individually for better error messages
    if (!account) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "account is required",
      });
    }

    if (!guard || !guard.keys || !guard.keys.length || !guard.pred) {
      return res.status(400).json({
        error: "Invalid guard",
        details: "Guard must include keys array and pred",
      });
    }

    if (!mintTo) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "mintTo is required",
      });
    }

    if (!uri) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "uri is required",
      });
    }

    if (!collectionId) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "collectionId is required",
      });
    }

    // 2. Validate account formats
    if (!account.startsWith("k:")) {
      return res.status(400).json({
        error: "Invalid account format",
        details: "account must start with k:",
      });
    }

    if (!mintTo.startsWith("k:")) {
      return res.status(400).json({
        error: "Invalid mintTo format",
        details: "mintTo must start with k:",
      });
    }

    // 3. Validate royalty parameters for royalty policies
    if (policy.includes("ROYALTY")) {
      if (royalties <= 0) {
        return res.status(400).json({
          error: "Invalid royalty",
          details: "Royalties must be greater than 0 for royalty policies",
        });
      }

      if (!royaltyRecipient) {
        return res.status(400).json({
          error: "Missing royalty recipient",
          details: "royaltyRecipient is required for royalty policies",
        });
      }

      if (!royaltyRecipient.startsWith("k:")) {
        return res.status(400).json({
          error: "Invalid royaltyRecipient format",
          details: "royaltyRecipient must start with k:",
        });
      }
    }

    // 4. Validate guard keys
    if (guard.keys.some((k) => typeof k !== "string" || k.length !== 64)) {
      return res.status(400).json({
        error: "Invalid guard keys",
        details: "Guard keys must be 64-character hex public keys",
      });
    }

    const pactClient = getClient(chainId);

    try {
      // 5. Generate the token ID based on Marmalade implementation
      let tokenId;
      try {
        let policyName;
        if (policy === "DEFAULT_COLLECTION_NON_UPDATABLE") {
          policyName = "marmalade-v2.non-fungible-policy-v1";
        } else if (policy === "DEFAULT_COLLECTION_ROYALTY_NON_UPDATABLE") {
          policyName = "marmalade-v2.royalty-policy-v1";
        } else {
          policyName = policy;
        }

        // Call to create-token-id
        const tokenIdCmd = Pact.builder
          .execution(
            `(use marmalade-v2.ledger)(use marmalade-v2.util-v1)
                     (create-token-id { 'precision: ${precision}, 'policies: [${policyName}], 'uri: "${uri}"} (read-keyset 'ks))`
          )
          .setMeta({
            chainId: String(chainId),
            gasLimit: 80000,
            gasPrice: 0.0000001,
            creationTime: creationTime(),
            ttl: 600,
          })
          .addKeyset("ks", guard.pred, ...guard.keys)
          .setNetworkId(KADENA_NETWORK_ID)
          .createTransaction();

        const tokenIdResult = await pactClient.dirtyRead(tokenIdCmd);

        if (
          tokenIdResult?.result?.status !== "success" ||
          !tokenIdResult.result.data
        ) {
          throw new Error(
            tokenIdResult?.result?.error?.message ||
              "Failed to generate token ID"
          );
        }

        tokenId = tokenIdResult.result.data;
        console.log("Generated token ID:", tokenId);
      } catch (tokenIdError) {
        console.error("Error generating token ID:", tokenIdError);
        return res.status(500).json({
          error: "Failed to generate token ID",
          details: tokenIdError.message,
        });
      }

      // 6. Fetch mintTo account's guard (needed for mint capability)
      let mintToGuard;
      try {
        const mintToGuardCmd = Pact.builder
          .execution(`(coin.details "${mintTo}")`)
          .setMeta({
            chainId: ensureChainIdString(chainId),
            creationTime: creationTime(),
            ttl: 600,
          })
          .setNetworkId(KADENA_NETWORK_ID)
          .createTransaction();

        const mintToGuardData = await pactClient.local(mintToGuardCmd, {
          preflight: false,
          signatureVerification: false,
        });

        if (
          mintToGuardData?.result?.status !== "success" ||
          !mintToGuardData.result.data?.guard
        ) {
          return res.status(404).json({
            error: "MintTo account not found",
            details:
              "Could not retrieve mintTo account details from blockchain",
          });
        }

        mintToGuard = mintToGuardData.result.data.guard;
      } catch (error) {
        console.error("Error fetching mintTo guard:", error);
        return res.status(500).json({
          error: "Failed to fetch mintTo account data",
          details: error.message,
        });
      }

      // 7. Construct the Pact code for NFT creation and minting
      const pactCode = `(use marmalade-v2.ledger)
(use marmalade-v2.util-v1)
(create-token 
  ${JSON.stringify(tokenId)} 
  ${precision} 
  (read-msg 'uri) 
  [${
    policy === "DEFAULT_COLLECTION_NON_UPDATABLE"
      ? "marmalade-v2.non-fungible-policy-v1"
      : policy === "DEFAULT_COLLECTION_ROYALTY_NON_UPDATABLE"
      ? "marmalade-v2.royalty-policy-v1"
      : policy
  }] 
  (read-keyset 'ks)
) 
(mint 
  ${JSON.stringify(tokenId)} 
  (read-msg 'mintTo) 
  (read-keyset 'mintToKs) 
  1.0
)`;

      // 8. Prepare environment data
      const envData = {
        uri: uri,
        mintTo: mintTo,
        collection_id: collectionId,
      };

      // Add optional metadata
      if (name) envData.name = name;
      if (description) envData.description = description;

      // Add royalty data if needed
      if (royalties > 0 && policy.includes("ROYALTY")) {
        envData.royaltyData = {
          royalty: royalties / 100,
          recipient: royaltyRecipient,
        };
      }

      // 9. Define capabilities with proper structure
      const capabilities = [
        {
          name: "Gas",
          args: [],
          pred: "coin.GAS",
        },
        {
          name: "Create Token",
          pred: "marmalade-v2.ledger.CREATE-TOKEN",
          args: [tokenId, precision, uri, guard],
        },
        {
          name: "Mint",
          pred: "marmalade-v2.ledger.MINT",
          args: [tokenId, mintTo, { decimal: "1.0" }],
        },
        {
          name: "Enforce Collection",
          pred: "marmalade-v2.collection-policy-v1.TOKEN-COLLECTION",
          args: [collectionId, tokenId],
        },
      ];

      // Add royalty capability if needed
      if (policy.includes("ROYALTY")) {
        capabilities.push({
          name: "Enforce Royalty",
          pred: "marmalade-v2.royalty-policy-v1.ENFORCE-ROYALTY",
          args: [tokenId],
        });
      }

      // 10. Transaction metadata
      const txMeta = {
        chainId: ensureChainIdString(chainId),
        sender: account,
        gasLimit: 10000,
        gasPrice: 0.0000001,
        ttl: 28800,
        creationTime: creationTime(),
      };

      // 11. Create the transaction
      const pactCommand = {
        networkId: KADENA_NETWORK_ID,
        payload: {
          exec: {
            data: envData,
            code: pactCode,
          },
        },
        signers: [
          {
            pubKey: guard.keys[0],
            scheme: "ED25519",
            clist: capabilities,
          },
        ],
        meta: txMeta,
        nonce: `mint:${Date.now()}:${Math.random()
          .toString(36)
          .substring(2, 15)}`,
      };

      // Final transaction object for client signing
      const preparedTx = {
        cmd: JSON.stringify(pactCommand),
        hash: "hash_placeholder", // Will be recalculated by the client
        sigs: [null], // Will be filled by the client
      };

      // 12. Return the transaction data with token ID
      return res.json({
        transaction: preparedTx,
        tokenId: tokenId,
        metadata: {
          name: name || "",
          description: description || "",
          uri: uri,
          collection: collectionId,
          royalties: royalties > 0 ? `${royalties}%` : "0%",
        },
      });
    } catch (error) {
      console.error("Error preparing NFT transaction:", error);
      return res.status(500).json({
        error: "Transaction preparation failed",
        details: error.message,
      });
    }
  } catch (error) {
    console.error("Unhandled error in /launch-nft endpoint:", error);
    return res.status(500).json({
      error: "Internal server error",
      details: NODE_ENV === "production" ? undefined : error.message,
    });
  }
});

/**
 * POST /create-collection
 * Generates an unsigned transaction to create a new Marmalade collection.
 */
app.post("/create-collection", async (req, res) => {
  try {
    const {
      account, // k:account format
      guard, // { keys: [...], pred: '...' }
      name,
      description = "",
      totalSupply = 0, // 0 means unlimited
      chainId = "2",
    } = req.body;

    // 1. Validate required parameters
    if (ensureChainIdString(chainId) !== "2") {
      return res.status(400).json({
        error: "Operation not supported",
        details: "Currently only chainId 2 is supported",
      });
    }

    if (!account) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "account is required",
      });
    }

    if (!guard || !guard.keys || !guard.keys.length || !guard.pred) {
      return res.status(400).json({
        error: "Invalid guard",
        details: "Guard must include keys array and pred",
      });
    }

    if (!name) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "Collection name is required",
      });
    }

    // 2. Validate account format
    if (!account.startsWith("k:")) {
      return res.status(400).json({
        error: "Invalid account format",
        details: "Kadena account must start with k:",
      });
    }

    // 3. Validate guard keys
    if (guard.keys.some((k) => typeof k !== "string" || k.length !== 64)) {
      return res.status(400).json({
        error: "Invalid guard keys",
        details: "Guard keys must be 64-character hex public keys",
      });
    }

    // 4. Generate a collection ID (optional - could be server-side or client-side)
    const pactClient = getClient(chainId);

    try {
      // Create collection ID first using Marmalade v2 collection policy
      const collectionIdCmd = Pact.builder
        .execution(
          `(use marmalade-v2.collection-policy-v1)
                   (create-collection-id ${JSON.stringify(
                     name
                   )} (read-keyset 'ks))`
        )
        .setMeta({
          chainId: ensureChainIdString(chainId),
          gasLimit: 15000,
          gasPrice: 0.0000001,
          creationTime: creationTime(),
          ttl: 600,
        })
        .addKeyset("ks", guard.pred, ...guard.keys)
        .setNetworkId(KADENA_NETWORK_ID)
        .createTransaction();

      const collectionIdResult = await pactClient.dirtyRead(collectionIdCmd);

      if (
        collectionIdResult?.result?.status !== "success" ||
        !collectionIdResult.result.data
      ) {
        console.error(
          "Failed to generate collection ID:",
          collectionIdResult?.result?.error || "Unknown error"
        );
        return res.status(500).json({
          error: "Failed to generate collection ID",
          details:
            collectionIdResult?.result?.error?.message ||
            "Could not generate a valid collection ID",
        });
      }

      const collectionId = collectionIdResult.result.data;

      // 5. Construct the Pact code for collection creation
      const pactCode = `(use marmalade-v2.collection-policy-v1)
  (marmalade-v2.collection-policy-v1.create-collection
    ${JSON.stringify(collectionId)}
    (read-msg 'name)
    (read-integer 'totalSupply)
    (read-keyset 'ks))`;

      // 6. Prepare environment data
      const envData = {
        name,
        description,
        collectionId,
        totalSupply: parseInt(totalSupply),
      };

      // 7. Define capabilities with proper structure
      const capabilities = [
        {
          name: "Gas",
          args: [],
          pred: "coin.GAS",
        },
        {
          name: "Create Collection",
          pred: "marmalade-v2.collection-policy-v1.ENFORCE-COLLECTION",
          args: [collectionId],
        },
      ];

      // 8. Transaction metadata
      const txMeta = {
        chainId: ensureChainIdString(chainId),
        sender: account,
        gasLimit: 10000,
        gasPrice: 0.0000001,
        ttl: 28800,
        creationTime: creationTime(),
      };

      // 9. Create the transaction manually for better control
      const pactCommand = {
        networkId: KADENA_NETWORK_ID,
        payload: {
          exec: {
            data: envData,
            code: pactCode,
          },
        },
        signers: [
          {
            pubKey: guard.keys[0],
            scheme: "ED25519",
            clist: capabilities,
          },
        ],
        meta: txMeta,
        nonce: `collection:${Date.now()}:${Math.random()
          .toString(36)
          .substring(2, 15)}`,
      };

      // Final transaction object for client signing
      const preparedTx = {
        cmd: JSON.stringify(pactCommand),
        hash: "hash_placeholder", // Will be recalculated by the client
        sigs: [null], // Will be filled by the client
      };

      // 10. Return the transaction data with collection ID
      return res.json({
        transaction: preparedTx,
        collectionId: collectionId,
      });
    } catch (error) {
      console.error("Error building collection creation transaction:", error);
      return res.status(500).json({
        error: "Transaction preparation failed",
        details: error.message,
      });
    }
  } catch (error) {
    console.error("Unhandled error in /create-collection endpoint:", error);
    return res.status(500).json({
      error: "Internal server error",
      details: NODE_ENV === "production" ? undefined : error.message,
    });
  }
});

/**
 * POST /transfer
 * Generate unsigned transaction data for token transfers between accounts
 *
 * @param {string} tokenAddress - The token contract address/module
 * @param {string} sender - The sender's account address
 * @param {string} receiver - The receiver's account address
 * @param {string} amount - The amount to transfer
 * @param {string} chainId - The chain ID to execute on
 * @param {string} [meta] - Optional metadata for the transfer
 * @param {number} [gasLimit] - Optional gas limit (default: 2500)
 * @param {number} [gasPrice] - Optional gas price (default: 0.00000001)
 * @param {number} [ttl] - Optional time-to-live in seconds (default: 600)
 */
app.post("/transfer", async (req, res) => {
  try {
    const {
      tokenAddress,
      sender,
      receiver,
      amount,
      chainId,
      meta = {},
      gasLimit = 2500,
      gasPrice = 0.00000001,
      ttl = 600,
    } = req.body;

    // 1. Validate required parameters
    if (!tokenAddress) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "tokenAddress is required",
      });
    }

    if (!sender) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "sender is required",
      });
    }

    if (!receiver) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "receiver is required",
      });
    }

    if (!amount) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "amount is required",
      });
    }

    if (!chainId) {
      return res.status(400).json({
        error: "Missing required parameter",
        details: "chainId is required",
      });
    }

    // 2. Validate amount format
    let parsedAmount;
    try {
      parsedAmount = new BigNumber(amount);
      if (parsedAmount.isNaN() || parsedAmount.isLessThanOrEqualTo(0)) {
        return res.status(400).json({
          error: "Invalid amount",
          details: "Amount must be a positive number",
        });
      }
    } catch (error) {
      return res.status(400).json({
        error: "Invalid amount format",
        details: error.message,
      });
    }

    // 3. Validate account formats
    if (sender.startsWith("k:") && sender.length < 66) {
      return res.status(400).json({
        error: "Invalid sender format",
        details: "Sender account appears to be invalid",
      });
    }

    if (receiver.startsWith("k:") && receiver.length < 66) {
      return res.status(400).json({
        error: "Invalid receiver format",
        details: "Receiver account appears to be invalid",
      });
    }

    // 4. Get token precision from tokens.yml
    const tokenPrecision = getTokenPrecision(tokenAddress);
    console.log(`Using precision for ${tokenAddress}: ${tokenPrecision}`);

    // 5. Format amount with proper precision
    const formattedAmount = reduceBalance(parsedAmount, tokenPrecision);

    // 6. Extract public key from sender (remove 'k:' prefix if present)
    const senderKey = sender.startsWith("k:") ? sender.slice(2) : sender;

    // 7. Prepare transaction metadata
    const txMeta = {
      creationTime: creationTime(),
      ttl,
      gasLimit,
      gasPrice,
      chainId: ensureChainIdString(chainId),
      sender,
      ...meta,
    };

    // 8. Create client and transaction
    const client = getClient(chainId);
    let cmd;

    try {
      if (tokenAddress === "coin") {
        // Native KDA transfer
        cmd = Pact.builder
          .execution(
            Pact.modules.coin["transfer"](sender, receiver, {
              decimal: formattedAmount,
            })
          )
          .setMeta(txMeta)
          .setNetworkId(KADENA_NETWORK_ID)
          .addSigner({ pubKey: senderKey }, (withCap) => [
            withCap(Pact.lang.mkCap("Gas", "Pay gas", "coin.GAS", [])),
            withCap(
              Pact.lang.mkCap(
                "Transfer",
                "Capability to transfer funds",
                "coin.TRANSFER",
                [sender, receiver, { decimal: formattedAmount }]
              )
            ),
          ])
          .createTransaction();
      } else {
        // Fungible token transfer (using fungible-v2 standard)
        cmd = Pact.builder
          .execution(
            `(${tokenAddress}.transfer "${sender}" "${receiver}" (read-decimal "amount"))`
          )
          .addData({ amount: { decimal: formattedAmount } })
          .setMeta(txMeta)
          .setNetworkId(KADENA_NETWORK_ID)
          .addSigner({ pubKey: senderKey }, (withCap) => [
            withCap(Pact.lang.mkCap("Gas", "Pay gas", "coin.GAS", [])),
            withCap(
              Pact.lang.mkCap(
                "Transfer",
                "Capability to transfer tokens",
                `${tokenAddress}.TRANSFER`,
                [sender, receiver, { decimal: formattedAmount }]
              )
            ),
          ])
          .createTransaction();
      }

      // 9. Return the transaction and metadata
      return res.status(200).json({
        transaction: cmd,
        metadata: {
          sender,
          receiver,
          amount: parsedAmount.toNumber(),
          tokenAddress,
          chainId,
          networkId: KADENA_NETWORK_ID,
          estimatedGas: gasLimit * gasPrice,
          formattedAmount,
        },
      });
    } catch (error) {
      console.error("Error building transfer transaction:", error);
      return res.status(500).json({
        error: "Transaction preparation failed",
        details: error.message,
      });
    }
  } catch (error) {
    console.error("Unhandled error in /transfer endpoint:", error);
    return res.status(500).json({
      error: "Internal server error",
      details: NODE_ENV === "production" ? undefined : error.message,
    });
  }
});

// --- Server Start ---
if (require.main === module) {
  // Only start the server if this file is run directly, not when imported for testing
  app.listen(PORT, () => {
    console.log(`Kadena API server listening on port ${PORT}`);
    console.log(
      `Targeting Kadena Network ID: ${KADENA_NETWORK_ID} on ${KADENA_API_HOST}`
    );
    console.log(`Using Kaddex Namespace: ${KADDEX_NAMESPACE}`);
    console.log(`Environment: ${NODE_ENV}`);
    console.log("---");
    console.log("Available Endpoints:");
    console.log(`GET /health (Health check endpoint)`);
    console.log(
      `POST /quote (Body: { tokenInAddress, tokenOutAddress, amountIn | amountOut, chainId: "2" })`
    );
    console.log(
      `POST /swap (Body: { tokenInAddress, tokenOutAddress, amountIn | amountOut, account, slippage?, chainId: "2" })`
    );
    console.log(
      `POST /launch-nft (Body: { account, guard, mintTo, uri, precision?, policy?, collectionId, royalties?, royaltyRecipient?, name?, description?, chainId: "2" })`
    );
    console.log(
      `POST /create-collection (Body: { account, guard, name, description?, totalSupply?, chainId: "2" })`
    );
    console.log(
      `POST /transfer (Body: { tokenAddress, sender, receiver, amount, chainId, meta?, gasLimit?, gasPrice?, ttl? })`
    );
  });
}

// Export the app for testing
module.exports = app;
